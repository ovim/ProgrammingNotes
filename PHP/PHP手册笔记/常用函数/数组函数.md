#### array_change_key_case

将数组中的所有键名修改为全大写或小写

**说明**

```php
array_change_key_case ( array $array [, int $case = CASE_LOWER] ) : array
```

​	**array_change_key_case()** 将 `array` 数组中的所有键名改为全小写或大写。本函数不改变数字索引。

**参数**

`array`

​	需要操作的数组。

`
case
`

​	可以在这里用两个常量，**`CASE_UPPER`** 或 **`CASE_LOWER`**（默认值）。

​	CASE_UPPER：大写		 CASE_LOWER：小写

**返回值**

​	返回一个键全是小写或者全是大写的数组；如果输入值（`array`）不是一个数组，那么返回**`FALSE`**

**注释**

> **Note**: 
>
> 如果一个数组中的多个键名经过本函数后变成一样的话（例如 "*keY*" 和 "*kEY*"），最后一个值将覆盖其它的值。

------



#### array_chunk

将一个数组分割成多个

**说明**

```php
array_chunk ( array $array , int $size [, bool $preserve_keys = false ] ) : array
```

​	将一个数组分割成多个数组，其中每个数组的单元数目由 `size` 决定。最后一个数组的单元数目可能会少于 `size` 个。

**参数**

`array`

​	需要操作的数组

`size`

​	每个数组的单元数目

`preserve_keys`

​	设为 TRUE，可以使 PHP 保留输入数组中原来的键名。如果你指定了 FALSE，那每个结果数组将用从零开始的新数字索引。默认值是 FALSE。

**返回值**

​	得到的数组是一个多维数组中的单元，其索引从零开始，每一维包含了 `size`个元素。

**错误/异常**

​	如果 `size` 小于 1，会抛出一个 **`E_WARNING`** 错误并返回 **`NULL`**。

------



#### array_column

返回数组中指定的一列

**说明**

```php
array_column ( array $input , mixed $column_key [, mixed $index_key = null ] ) : array
```

​	**array_column()** 返回`input`数组中键值为`column_key`的列， 如果指定了可选参数`index_key`，那么`input`数组中的这一列的值将作为返回数组中对应值的键。

参数**

`input`

​	需要取出数组列的多维数组。 如果提供的是包含一组对象的数组，只有 public 属性会被直接取出。 为了也能取出 private 和 protected 属性，类必须实现 `__get()` 和 `__isset()` 魔术方法，如果不提供 `__isset`，会返回空数组。

`column_key`

​	需要返回值的列，它可以是索引数组的列索引，或者是关联数组的列的键，也可以是属性名。 也可以是NULL，此时将返回整个数组（配合index_key参数来重置数组键的时候，非常管用）

`index_key`

​	作为返回数组的索引/键的列，它可以是该列的整数索引，或者字符串键值。

**返回值**

​	从多维数组中返回单列数组。

------



#### array_combine

创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值。

**说明**

```php
array_combine ( array $keys , array $values ) : array
```

​	返回一个 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html)，用来自 `keys` 数组的值作为键名，来自 `values` 数组的值作为相应的值。

**参数**

`keys`

​	将被作为新数组的键。非法的值将会被转换为字符串类型（string）。

`values`

​	将被作为 Array 的值。

**返回值**

​	返回合并的 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html)，如果两个数组的单元数不同则返回 **`FALSE`**。

**错误/异常**

​	如果作为`keys`的数组和作为`values`的数组的元素个数不一样，将会抛出一个警告错误（**`E_WARNING`**）。

------



#### array_count_values

统计数组中所有的值

**说明**

```php
array_count_values ( array $array ) : array
```

​	**array_count_values()** 返回一个数组： 数组的键是 `array` 里单元的值； 数组的值是 `array` 单元的值出现的次数。

**参数**

`input`

​	统计这个数组的值	

**返回值**

​	返回一个关联数组，用 `array` 数组中的值作为键名，该值在数组中出现的次数作为值。

**错误/异常**

​	对数组里面的每个不是 [string](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.string.html) 和 [integer](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.integer.html) 类型的元素抛出一个警告错误（**`E_WARNING`**）。

------



#### array_diff_assoc

带索引检查计算数组的差集

**说明**

```php
array_diff_assoc ( array $array1 , array $array2 [, array $... ] ) : array
```

​	**array_diff_assoc()** 返回一个数组，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。注意和 [array_diff()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-diff.html) 不同的是键名也用于比较。

**参数**

`array1`

​	从这个数组进行比较

`array2`

​	被比较的数组

`...`

​	更多被比较的数组

**返回值**

​	**array_diff_assoc()** 返回一个数组，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。注意和 [array_diff()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-diff.html) 不同的是键名也用于比较。

**总结**

​	相互比较数组的键值对必须一致，才不会出现在返回值中；

​	使用了严格检查，字符串的表达必须相同。

**范例**

```php
<?php
$array1 = array(0, 1, 2);
$array2 = array("00", "01", "2");
$result = array_diff_assoc($array1, $array2);
print_r($result);
?>
```

以上例程会输出：

```
Array
(
    [0] => 0
    [1] => 1
    )
```

**注释**

> **Note**: 注意本函数只检查了多维数组中的一维。当然可以用*array_diff_assoc($array1[0], $array2[0]);* 检查更深的维度。

> **Note**: 使用更多的键比较相似数组时，确保你传入参数的顺序是正确的。 新的数组应该是在列表里的第一个。

------



#### array_diff_key

使用键名比较计算数组的差集

**说明**

```php
array_diff_key ( array $array1 , array $array2 [, array $... ] ) : array
```

​	根据 `array1` 中的键名和 `array2` 进行比较，返回不同键名的项。 本函数和[array_diff()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-diff.html) 相同只除了比较是根据键名而不是值来进行的。

**参数**

`array1`

​	从这个数组进行比较

`array2`

​	针对此数组进行比较

`...`

​	更多比较数组

**返回值**

​	**array_diff_key()** 返回一个数组，该数组包括了所有出现在 `array1` 中但是未出现在任何其它参数数组中的键名的值。

**注释**

> **Note**: 
>
> 注意本函数只检查了多维数组中的一维。当然，可以用*array_diff_key($array1[0], $array2[0]);* 来检查更深的维度。

------



#### =====array_diff_uassoc

#### =====array_diff_ukey

#### array_diff

计算数组的差集

**说明**

```php
array_diff ( array $array1 , array $array2 [, array $... ] ) : array
```

​	对比 `array1` 和其他一个或者多个数组，返回在 `array1` 中但是不在其他 array 里的值。

**参数**

`array1`

​	从这个数组进行比较

`array2`

​	针对此数组进行比较

`...`

​	更多比较数组

**返回值**

​	返回一个数组，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。注意键名保留不变。

------



#### array_fill_keys

使用指定的键和值填充数组

**说明**

```php
array_fill_keys ( array $keys , mixed $value ) : array
```

​	使用 `value` 参数的值作为值，使用 `keys` 数组的值作为键来填充一个数组。

**参数**

`keys`

​	使用该数组的值作为键。非法值将被转换为字符串。

`value`

​	填充使用的值。

**返回值**

​	返回填充后的数组。

**范例**

**Example #1 `array_fill_keys()` 范例**

```php
<?php
$keys = array('foo', 5, 10, 'bar');
$a = array_fill_keys($keys, 'banana');
print_r($a);
?>
```

以上例程会输出：

```
Array
(
    [foo] => banana
    [5] => banana
    [10] => banana
    [bar] => banana
)
```

------



#### array_fill

用给定的值填充数组

**说明**

```php
array_fill ( int $start_index , int $num , mixed $value ) : array
```

​	**array_fill()** 用 `value` 参数的值将一个数组填充 `num` 个条目，键名由`start_index` 参数指定的开始。

​	简单讲就是从`start_index`开始，填充`num`个`value`数组成一个新数组。

**参数**

`start_index`

​	返回的数组的第一个索引值。

​	如果 `start_index` 是负数， 那么返回的数组的第一个索引将会是`start_index` ，而后面索引则从0开始。 (参见 [例子](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-fill.html#function.array-fill.example.basic))。

`num`

​	插入元素的数量。 必须大于或等于 0。

`value`

​	用来填充的值。

**返回值**

​	返回填充后的数组。

**错误/异常**

​	如果 `num` 小于零，将会抛出 **`E_WARNING`**。

**范例**

**Example #1 `array_fill()` 例子**

```php
<?php
$a = array_fill(5, 6, 'banana');
$b = array_fill(-2, 4, 'pear');
print_r($a);
print_r($b);
?>
```

以上例程会输出：

```
Array
(
    [5]  => banana
    [6]  => banana
    [7]  => banana
    [8]  => banana
    [9]  => banana
    [10] => banana
)
Array
(
    [-2] => pear
    [0] => pear
    [1] => pear
    [2] => pear
)
```

------



#### array_filter

用回调函数过滤数组中的单元

**说明**

```php
array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array
```

​	依次将 `array` 数组中的每个值传递到 `callback` 函数。如果 `callback` 函数返回 true，则 `array` 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。

**参数**

`array`

​	要循环的数组

`callback`

​	使用的回调函数

​	如果没有提供 `callback` 函数， 将删除 `array` 中所有等值为 **`FALSE`** 的条目。更多信息见[转换为布尔值](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.boolean.html#language.types.boolean.casting)。

`falg`

决定`callback`接收的参数形式:

- **`ARRAY_FILTER_USE_KEY`** - `callback`接受键名作为的唯一参数

- **`ARRAY_FILTER_USE_BOTH`** - `callback`同时接受键名和键值

**返回值**

​	返回过滤后的数组。

**范例**

**Example #1 `array_filter()` 例子**

```php
<?php
function odd($var)
{
    // returns whether the input integer is odd
    return($var & 1);
}

function even($var)
{
    // returns whether the input integer is even
    return(!($var & 1));
}

$array1 = array("a"=>1, "b"=>2, "c"=>3, "d"=>4, "e"=>5);
$array2 = array(6, 7, 8, 9, 10, 11, 12);

echo "Odd :\n";
print_r(array_filter($array1, "odd"));
echo "Even:\n";
print_r(array_filter($array2, "even"));
?>
```

以上例程会输出：

```
Odd :
Array
(
    [a] => 1
    [c] => 3
    [e] => 5
)
Even:
Array
(
    [0] => 6
    [2] => 8
    [4] => 10
    [6] => 12
)
```

**Example #3 带 `flag` 标记的 `array_filter()`**

```php
<?php

$arr = ['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4];

var_dump(array_filter($arr, function($k) {
    return $k == 'b';
}, ARRAY_FILTER_USE_KEY));

var_dump(array_filter($arr, function($v, $k) {
    return $k == 'b' || $v == 4;
}, ARRAY_FILTER_USE_BOTH));
?>
```

以上例程会输出：

```
array(1) {
  ["b"]=>
  int(2)
}
array(2) {
  ["b"]=>
  int(2)
  ["d"]=>
  int(4)
}
```

**注释**

> **Caution**
>
> ***用户不应在回调函数中修改数组本身。***例如增加／删除单元或者对 **array_filter()** 正在作用的数组进行 unset。如果数组改变了，此函数的行为将不可预测。

------



#### array_flip

交换数组中的键和值

**说明**

```php
array_flip ( array $array ) : array
```

​	**array_flip()** 返回一个反转后的 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html)，例如 `array` 中的键名变成了值，而`array` 中的值成了键名。

​	注意 `array` 中的值需要能够作为合法的键名（例如需要是 [integer](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.integer.html) 或者 [string](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.string.html)）。如果类型不对，将出现一个警告，并且有问题的键／值对*将不会出现在结果里*。

​	如果同一个值出现多次，则最后一个键名将作为它的值，其它键会被丢弃。

**参数**

`array`

​	需要交换键/值对的数组

**返回值**

​	成功时返回交换后的数组，如果失败返回NULL。

------



#### array_intersect_assoc

带索引检查数组的交集

**说明**

```php
array_intersect_assoc ( array $array1 , array $array2 [, array $... ] ) : array
```

​	**array_intersect_assoc()** 返回一个数组，该数组包含了所有在 `array1` 中也同时出现在所有其它参数数组中的值。注意和 [array_intersect()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-intersect.html) 不同的是键名也用于比较。

**参数**

`array1`

​	要检查的主值。

`array2`

​	要比较的数组。

`...`

​	要对比的数组变量的列表。

**返回值**

​	返回数组，该数组包含了所有在 `array1` 中也同时出现在所有其它参数数组中的值。

------



#### array_intersect_key

使用键名比较计算数组的交集

**说明**

```php
array_intersect_key ( array $array1 , array $array2 [, array $... ] ) : array
```

​	**array_intersect_key()** 返回一个数组，该数组包含了所有出现在 `array1` 中并同时出现在所有其它参数数组中的键名的值。***返回的值只是`array1`的。***

**参数**

`array1`

​	要检查的主值。

`array2`

​	要比较的数组。

`...`

​	要对比的数组变量的列表。

**返回值**

​	返回数组，该数组包含了所有出现在 `array1` 中并同时出现在所有其它参数数组中的键名的值。***返回的值只是`array1`的。*******

------



#### =====array_intersect_uassoc

#### =====array_intersect_ukey

#### array_intersect

计算数组的交集

**说明**

```php
array_intersect ( array $array1 , array $array2 [, array $... ] ) : array
```

​	**array_intersect()** 返回一个数组，该数组包含了所有在 `array1` 中也同时出现在所有其它参数数组中的值。

​	***注意键名保留不变，继续使用`array1`的键名。***

**参数**

`array1`

​	要检查的数组，作为主值。

`array2`

​	要被对比的数组。

`...`

​	要对比的数组列表。

**返回值**

​	返回一个数组，该数组包含了所有在 `array1` 中也同时出现在所有其它参数数组中的值。

------



#### array_key_exists / key_exists

检查数组里是否有指定的键名或索引

**说明**

```php
array_key_exists ( mixed $key , array $array ) : bool
```

​	数组里有键 `key` 时，**array_key_exists()** 返回 **`TRUE`**。 `key` 可以是任何能作为数组索引的值。

**参数**

`key`

​	要检查的键

`array`

​	一个数组，包含待检查的键

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

> **Note**: 
>
> **array_key_exists()** 仅仅搜索第一维的键。 多维数组里嵌套的键不会被搜索到。

------



#### array_key_first

获取数组的第一个键

**说明**

```php
array_key_first( array $array) : array
```

**返回值**

​	如果数组不为空 ，则返回第一个键。 否则为**`NULL`**。

------



#### array_key_last

获取数组的最后一个键

**说明**

```php
array_key_last( array $array) : array
```

**返回值**

​	如果数组不为空 ，则返回最后一个键。 否则为**`NULL`**。

------



#### array_keys

返回数组中部分或所有的键名

**说明**

```php
array_keys ( array $array [, mixed $search_value = null [, bool $strict = false ]] ) : array
```

​	**array_keys()** 返回 `input` 数组中的数字或者字符串的键名。

​	如果指定了可选参数 `search_value`，则只返回该值的键名。否则 `input` 数组中的所有键名都会被返回。

**参数**

`input`

​	一个数组，包含了要返回的键。

`search_value`

​	如果指定了这个参数，只有包含这些值的键才会返回。

`strict`

​	判断在搜索的时候是否该使用严格的比较（===）。

**返回值**

​	将包含符合条件的键组成新数组返回。

------



#### array_map

为数组的每个元素应用回调函数

**说明**

```php
array_map ( callable $callback , array $array1 [, array $... ] ) : array
```

​	**array_map()**：返回数组，是为 `array1` 每个元素应用 `callback`函数之后的数组。 `callback` 函数形参的数量和传给 **array_map()** 数组数量，两者必须一样。

**参数**

`callback`

​	回调函数，应用到每个数组里的每个元素。

`array1`

​	数组，遍历运行 `callback` 函数。

`...`

​	数组列表，每个都遍历运行 `callback` 函数。

**返回值**

​	返回数组，包含 `callback` 函数处理之后 `array1` 的所有元素。

**范例**

**Example #1 `array_map()`例子**

```php
<?php
function cube($n)
{
    return($n * $n * $n);
}

$a = array(1, 2, 3, 4, 5);
$b = array_map("cube", $a);
print_r($b);
?>
```

这使得 $b 成为：

```
Array
(
    [0] => 1
    [1] => 8
    [2] => 27
    [3] => 64
    [4] => 125
)
```

传入两个及以上的数组时，它们元素数量将会相同。因为回调函数会并行地处理相互对应的元素。 如果几个数组的元素数量不一致：空元素会扩展短那个数组，直到长度和最长的数组一样。

此函数有个有趣的用法：传入 **`NULL`** 作为回调函数的名称，将创建多维数组（一个数组，内部包含数组。）

**Example #4 多维数组：创建数组，内部包含数组**

```php
<?php
$a = array(1, 2, 3, 4, 5);
$b = array("one", "two", "three", "four", "five");
$c = array("uno", "dos", "tres", "cuatro", "cinco");

$d = array_map(null, $a, $b, $c);
print_r($d);
?>
```

以上例程会输出：

```
Array
(
    [0] => Array
        (
            [0] => 1
            [1] => one
            [2] => uno
        )

    [1] => Array
        (
            [0] => 2
            [1] => two
            [2] => dos
        )

    [2] => Array
        (
            [0] => 3
            [1] => three
            [2] => tres
        )

    [3] => Array
        (
            [0] => 4
            [1] => four
            [2] => cuatro
        )

    [4] => Array
        (
            [0] => 5
            [1] => five
            [2] => cinco
        )

)
```

如果仅传入一个数组，键（key）会保留；传入多个数组，键（key）是整型数字的序列。

------



#### array_merge_recursive

递归地合并一个或多个数组

**说明**

```php
array_merge_recursive ( array $array1 [, array $... ] ) : array
```

​	**array_merge_recursive()** 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。

​	如果输入的数组中有相同的字符串键名，则这些值会被合并到一个数组中去，这将递归下去，因此如果一个值本身是一个数组，本函数将按照相应的条目把它合并为另一个数组。需要注意的是，如果数组具有相同的数值键名，后一个值将不会覆盖原来的值，而是附加到后面。

**参数**

`array1`

​	要合并的初始数组。

`...`

​	数组变量列表，进行递归合并。

**返回值**

​	一个结果数组，其中的值合并自附加的参数。

**范例**

**Example #1 `array_merge_recursive()` 例子**

```php
<?php
$ar1 = array("color" => array("favorite" => "red"), 5);
$ar2 = array(10, "color" => array("favorite" => "green", "blue"));
$result = array_merge_recursive($ar1, $ar2);
print_r($result);
?>
```

以上例程会输出：

```
Array
(
    [color] => Array
        (
            [favorite] => Array
                (
                    [0] => red
                    [1] => green
                )

            [0] => blue
        )

    [0] => 5
    [1] => 10
)
```

------



#### array_merge

合并一个或多个数组

**说明**

```php
array_merge ( array $array1 [, array $... ] ) : array
```

​	**array_merge()** 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。

> 如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。

> 然而，如果数组包含数字键名，后面的值将*不会*覆盖原来的值，而是附加到后面。

​	如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。

**参数**

`array1`

​	要合并的第一个数组。

`...`

​	要合并的数组列表。

**返回值**

​	返回结果数组。

**注释**

​	如果你想完全保留原有数组并只想新的数组附加到后面，用 *+* 运算符。在两个数组中存在相同的键名时，第一个数组中的同键名的元素将会被保留，第二个数组中的元素将会被忽略。

------



#### =====array_multisort

对多个数组或多维数组进行排序

**说明**

```php
array_multisort ( array &$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $... ]]] ) : bool
```

​	**array_multisort()** 可以用来一次对多个数组进行排序，或者根据某一维或多维对多维数组进行排序。

​	关联（[string](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.string.html)）键名保持不变，但数字键名会被重新索引。

**参数**

`array1`

要排序的 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html)。

`array1_sort_order`

之前 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html) 参数要排列的顺序。 **`SORT_ASC`** 按照上升顺序排序， **`SORT_DESC`** 按照下降顺序排序。

此参数可以和 `array1_sort_flags` 互换，也可以完全删除，默认是 **`SORT_ASC`** 。

`array1_sort_flags`

为 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html) 参数设定选项：

排序类型标志：

- **`SORT_REGULAR`** - 将项目按照通常方法比较（不修改类型）
- **`SORT_NUMERIC`** - 按照数字大小比较
- **`SORT_STRING`** - 按照字符串比较
- **`SORT_LOCALE_STRING`** - 根据当前的本地化设置，按照字符串比较。 它会使用 locale 信息，可以通过 [setlocale()](chm://81c5fd530434a6e8d06943912d065c49/res/function.setlocale.html) 修改此信息。
- **`SORT_NATURAL`** - 以字符串的"自然排序"，类似 [natsort()](chm://81c5fd530434a6e8d06943912d065c49/res/function.natsort.html)
- **`SORT_FLAG_CASE`** - 可以组合 (按位或 OR) **`SORT_STRING`** 或者**`SORT_NATURAL`** 大小写不敏感的方式排序字符串。

参数可以和 `array1_sort_order` 交换或者省略，默认情况下是 **`SORT_REGULAR`**。

`...`

可选的选项，可提供更多数组，跟随在 sort order 和 sort flag 之后。 提供的数组和之前的数组要有相同数量的元素。 换言之，排序是按字典顺序排列的。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**

------



#### array_pad

以指定长度将一个值填充进数组

**说明**

```php
array_pad ( array $array , int $size , mixed $value ) : array
```

​	**array_pad()** 返回 `array` 的一个拷贝，并用 `value` 将其填补到 `size` 指定的长度。

​	如果 `size` 为正，则填补到数组的右侧，如果为负则从左侧开始填补。

​	如果 `size` 的绝对值小于或等于 `array` 数组的长度则没有任何填补。

​	有可能一次最多填补 1048576 个单元。

**参数**

`array`

​	需要被填充的原始数组。

`size`

​	新数组的长度。

`value`

​	将被填充的值，只有在 `array` 的现有长度小于 `size` 的长度时才有效。

**返回值**

​	返回 `array` 用 `value` 填充到 `size` 指定的长度之后的一个副本。 如果 `size`为正，则填补到数组的右侧，如果为负则从左侧开始填补。 如果 `size` 的绝对值小于或等于 `array` 数组的长度则没有任何填补。

------



#### array_pop

弹出数组最后一个单元（出栈）

**说明**

```php
array_pop ( array &$array ) : mixed
```

​	**array_pop()** 弹出并返回 `array` 数组的最后一个单元，并将数组 `array` 的长度减一。

> **Note**: 使用此函数后会重置（[reset()](chm://81c5fd530434a6e8d06943912d065c49/res/function.reset.html)）[array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html) 指针。

**参数**

`array`

​	需要弹出栈的数组。

**返回值**

​	返回 `array` 的最后一个值。如果 `array` 是空（如果不是一个数组），将会返回 **`NULL`** 。

**错误/异常**

​	调用此函数去处理非数组的值，会产生 [E_WARNING](chm://81c5fd530434a6e8d06943912d065c49/res/errorfunc.constants.html) 级别的错误。

------



#### array_product

计算数组中所有值的乘积

**说明**

```php
array_product ( array $array ) : number
```

**返回值**

​	 以整数或浮点数返回一个数组中所有值的乘积。

**注意**

​	在5.3.6之后，空数组会产生1，而之前此函数处理空数组会产生0。

------



#### array_push

将一个或多个单元压入数组的末尾（入栈）

**说明**

```php
array_push ( array &$array , mixed $value1 [, mixed $... ] ) : int
```

**array_push()** 将 `array` 当成一个栈，并将传入的变量压入 `array` 的末尾。`array` 的长度将根据入栈变量的数目增加。和如下效果相同：

```php
<?php
$array[] = $var;
?>
```

并对每个传入的值重复以上动作。

> **Note**: 如果用 **array_push()** 来给数组增加一个单元，还不如用 *$array[] =* ，因为这样没有调用函数的额外负担。

> **Note**: 如果第一个参数不是数组，**array_push()** 将发出一条警告。这和*$var[]* 的行为不同，后者会新建一个数组。

**参数**

`array`

​	输入的数组。

`value1`

​	要压入 `array` 末尾的第一个值。

**返回值**

​	返回处理之后数组的元素个数

------



#### array_rand

从数组中随机取出一个或多个单元

**说明**

```php
array_rand ( array $array [, int $num = 1 ] ) : mixed
```

​	从数组中取出一个或多个随机的单元，并返回随机条目的一个或多个键。 它使用了伪随机数产生算法，所以不适合密码学场景

​	返回的数组中的键名。

**参数**

`array`

​	输入的数组。

`num`

​	指明了你想取出多少个单元。

**返回值**

​	如果只取出一个，**array_rand()** 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。 取出数量如果超过 array 的长度，就会导致 **`E_WARNING`** 错误，并返回 NULL。

------



#### array_reduce

用回调函数迭代地将数组简化为单一的值

**说明**

```php
array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) : mixed
```

​	**array_reduce()** 将回调函数 `callback` 迭代地作用到 `array` 数组中的每一个单元中，从而将数组简化为单一的值。

**参数**

`array`

​	输入的 array。

`callback`

​	callback ( [mixed](chm://81c5fd530434a6e8d06943912d065c49/res/language.pseudo-types.html#language.types.mixed) `$carry` , [mixed](chm://81c5fd530434a6e8d06943912d065c49/res/language.pseudo-types.html#language.types.mixed) `$item` ) : [mixed](chm://81c5fd530434a6e8d06943912d065c49/res/language.pseudo-types.html#language.types.mixed)

- `carry`

  携带上次迭代里的值； 如果本次迭代是第一次，那么这个值是 `initial`。

- `item`

  携带了本次迭代的值。

`initial`

​	如果指定了可选参数 `initial`，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。

**返回值**

​	返回结果值。

​	`initial` 参数，**array_reduce()** 返回 **`NULL`**。

**范例**

**Example #1 `array_reduce()` 例子**

```php
<?php
function sum($carry, $item)
{
    $carry += $item;
    return $carry;
}

function product($carry, $item)
{
    $carry *= $item;
    return $carry;
}

$a = array(1, 2, 3, 4, 5);
$x = array();

var_dump(array_reduce($a, "sum")); // int(15)
var_dump(array_reduce($a, "product", 10)); // int(1200), because: 10*1*2*3*4*5
var_dump(array_reduce($x, "sum", "No data to reduce")); // string(17) "No data to reduce"
?>
```

------



#### array_replace_recursive

使用传递的数组递归替换第一个数组的元素

**说明**

```php
array_replace_recursive ( array $array1 [, array $... ] ) : array
```

​	**array_replace_recursive()** 使用后面数组元素的值替换数组 `array1` 的值。 如果一个键存在于第一个数组同时也存在于第二个数组，它的值将被第二个数组中的值替换。 如果一个键存在于第二个数组，但是不存在于第一个数组，则会在第一个数组中创建这个元素。 如果一个键仅存在于第一个数组，它将保持不变。 如果传递了多个替换数组，它们将被按顺序依次处理，后面的数组将覆盖之前的值。

​	**array_replace_recursive()** 是递归的：它将遍历数组并将相同的处理应用到数组的内部值。

​	如果第一个数组中的值是标量，它的值将被第二个数组中的值替换，它可能是一个标量或者数组。如果第一个数组和第二个数组中的值都是数组，**array_replace_recursive()** 函数将递归地替换它们各自的值。

**总结**

​	在键名一样的情况下，再去比较值（非数组类型的直接替换；数组类型的进行添加）。

**参数**

`array1`

​	替换该数组的值。

`...`

​	包含要提取元素的数组。 

**返回值**

​	返回一个数组。如果发生错误，将返回 **`NULL`**。

**范例**

**Example #2 `array_replace_recursive()` 及其递归表现**

```php
<?php
$base = array('citrus' => array("orange") , 'berries' => array("blackberry", "raspberry"), 'others' => 'banana' );
$replacements = array('citrus' => 'pineapple', 'berries' => array('blueberry'), 'others' => array('litchis'));
$replacements2 = array('citrus' => array('pineapple'), 'berries' => array('blueberry'), 'others' => 'litchis');

$basket = array_replace_recursive($base, $replacements, $replacements2);
print_r($basket);

?>
```

以上例程会输出：

```
Array
(
    [citrus] => Array
        (
            [0] => pineapple
        )

    [berries] => Array
        (
            [0] => blueberry
            [1] => raspberry
        )

    [others] => litchis
)
```

------



#### array_replace

使用传递的数组替换第一个数组的元素

**说明**

```php
array_replace ( array $array1 [, array $... ] ) : array
```

​	**array_replace()** 函数使用后面数组元素相同 key 的值替换 `array1` 数组的值。如果一个键存在于第一个数组同时也存在于第二个数组，它的值将被第二个数组中的值替换。如果一个键存在于第二个数组，但是不存在于第一个数组，则会在第一个数组中创建这个元素。如果一个键仅存在于第一个数组，它将保持不变。如果传递了多个替换数组，它们将被按顺序依次处理，后面的数组将覆盖之前的值。

​	**array_replace()** 是非递归的：它将第一个数组的值进行替换而不管第二个数组中是什么类型。

**总结**

​	只要键名一样，后面的直接替换前面的值。

**参数**

`array1`

​	替换该数组的值。

`...`

​	包含要提取元素的数组。 后面的数组里的值会覆盖前面的值。

**返回值**

​	返回一个数组。如果发生错误，将返回 **`NULL`**。

**范例**

**Example #1`array_replace()` 范例**

```php
<?php
$base = array("orange", "banana", "apple", "raspberry");
$replacements = array(0 => "pineapple", 4 => "cherry");
$replacements2 = array(0 => "grape");

$basket = array_replace($base, $replacements, $replacements2);
print_r($basket);
?>
```

以上例程会输出：

```
Array
(
    [0] => grape
    [1] => banana
    [2] => apple
    [3] => raspberry
    [4] => cherry
)
```

------



#### array_reverse

返回单元顺序相反的数组

**说明**

```php
array_reverse ( array $array [, bool $preserve_keys = FALSE ] ) : array
```

​	**array_reverse()** 接受数组 `array` 作为输入并返回一个单元为相反顺序的新数组。

**参数**

`array`

​	输入的数组。

`preserve_keys`

​	如果设置为 **`TRUE`** 会保留数字的键。 非数字的键则不受这个设置的影响，总是会被保留。

**返回值**

​	返回反转后的数组。

------



#### array_search

在数组中搜索给定的值，如果成功则返回首个相应的键名

**说明**

```php
array_search ( mixed $needle , array $haystack [, bool $strict = false ] ) : mixed
```

​	大海捞针，在大海（`haystack`）中搜索针（ `needle` 参数）。

**参数**

`needle`

​	搜索的值。

> **Note**: 
>
> 如果 `needle` 是字符串，则比较以区分大小写的方式进行。

`haystack`

​	这个数组。

`strict`

​	如果可选的第三个参数 `strict` 为 **`TRUE`**，则 **array_search()** 将在 `haystack` 中检查*完全相同*的元素。 这意味着同样严格比较 `haystack`里 `needle` 的 [类型](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.html)，并且对象需是同一个实例。

**返回值**

​	如果找到了 `needle` 则返回它的键，否则返回 **`FALSE`**。

​	如果 `needle` 在 `haystack` 中出现不止一次，则返回第一个匹配的键。要返回所有匹配值的键，应该用 [array_keys()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-keys.html) 加上可选参数 `search_value` 来代替。

> **Warning**
>
> 此函数可能返回布尔值 **`FALSE`**，但也可能返回等同于 **`FALSE`** 的非布尔值。请阅读 [布尔类型](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.boolean.html)章节以获取更多信息。应使用 [=== 运算符](chm://81c5fd530434a6e8d06943912d065c49/res/language.operators.comparison.html)来测试此函数的返回值。

------



#### array_shift

将数组开头的单元移出数组

**说明**

```php
array_shift ( array &$array ) : mixed
```

​	**array_shift()** 将 `array` 的第一个单元移出并作为结果返回，将 `array` 的长度减一并将所有其它单元向前移动一位。所有的数字键名将改为从零开始计数，文字键名将不变。

> **Note**: 使用此函数后会重置（[reset()](chm://81c5fd530434a6e8d06943912d065c49/res/function.reset.html)）[array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html) 指针。

**参数**

`array`

​	输入的数组

**返回值**

​	返回移出的值，如果 `array` 为 空或不是一个数组则返回 **`NULL`**。

------



#### array_slice

从数组中取出一段

**说明**

```php
array_slice ( array $array , int $offset [, int $length = NULL [, bool $preserve_keys = false ]] ) : array
```

​	**array_slice()** 返回根据 `offset` 和 `length` 参数所指定的 `array` 数组中的一段序列。

**参数**

`array`

​	输入的数组。

`offset`

​	如果 `offset` 非负，则序列将从 `array` 中的此偏移量开始。如果 `offset` 为负，则序列将从 `array` 中距离末端这么远的地方开始。

`length`

​	如果给出了 `length` 并且为正，则序列中将具有这么多的单元。如果给出了 `length` 并且为负，则序列将终止在距离数组末端这么远的地方。如果省略，则序列将从 `offset` 开始一直到 `array` 的末端。

`preserve_keys`

​	注意 **array_slice()** 默认会重新排序并重置数组的数字索引。你可以通过将 `preserve_keys` 设为 **`TRUE`** 来改变此行为。

**返回值**

​	返回其中一段。 如果 offset 参数大于 array 尺寸，就会返回空的 array。

**范例**

**Example #1 `array_slice()` 例子**

```php
<?php
$input = array("a", "b", "c", "d", "e");

$output = array_slice($input, 2);      // returns "c", "d", and "e"
$output = array_slice($input, -2, 1);  // returns "d"
$output = array_slice($input, 0, 3);   // returns "a", "b", and "c"

// note the differences in the array keys
print_r(array_slice($input, 2, -1));
print_r(array_slice($input, 2, -1, true));
?>
```

以上例程会输出：

```
Array
(
    [0] => c
    [1] => d
)
Array
(
    [2] => c
    [3] => d
)
```

------



#### array_splice

去掉数组中的某一部分并用其他值取代

**说明**

```php
array_splice ( array &$input , int $offset [, int $length = count($input) [, mixed $replacement = array() ]] ) : array
```

​	把 `input` 数组中由 `offset` 和 `length` 指定的单元去掉，如果提供了 `replacement` 参数，则用其中的单元取代。

​	注意 `input` 中的数字键名不被保留。

> **Note**: 如果 `replacement` 不是数组，会被 [类型转换](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html#language.types.array.casting) 成数组 (例如： `(array) $replacement`)。 当传入的 `replacement` 是个对象或者 **`NULL`**，会导致未知的行为出现。

**参数**

`input`

​	输入的数组。

`offset`

​	如果 `offset` 为正，则从 `input` 数组中该值指定的偏移量开始移除。如果 `offset` 为负，则从 `input` 末尾倒数该值指定的偏移量开始移除。

`length`

​	如果省略 `length`，则移除数组中从 `offset` 到结尾的所有部分。如果指定了 `length` 并且为正值，则移除这么多单元。如果指定了 `length`并且为负值，则移除从 `offset` 到数组末尾倒数 `length` 为止中间所有的单元。 如果设置了 `length` 为零，不会移除单元。 小窍门：当给出了 `replacement` 时要移除从 `offset` 到数组末尾所有单元时，用 *count($input)* 作为 `length`。

`replacement`

​	如果给出了 `replacement` 数组，则被移除的单元被此数组中的单元替代。

​	如果 `offset` 和 `length` 的组合结果是不会移除任何值，则 `replacement` 数组中的单元将被插入到 `offset` 指定的位置。 注意替换数组中的键名不保留。

​	如果用来替换 `replacement` 只有一个单元，那么不需要给它加上*array()*，除非该单元本身就是一个数组、一个对象或者 **`NULL`**。

**返回值**

​	返回一个包含有被移除单元的数组。

**范例**

**Example #1 `array_splice()` 例子**

```php
<?php
$input = array("red", "green", "blue", "yellow");
array_splice($input, 2);
// $input is now array("red", "green")

$input = array("red", "green", "blue", "yellow");
array_splice($input, 1, -1);
// $input is now array("red", "yellow")

$input = array("red", "green", "blue", "yellow");
array_splice($input, 1, count($input), "orange");
// $input is now array("red", "orange")

$input = array("red", "green", "blue", "yellow");
array_splice($input, -1, 1, array("black", "maroon"));
// $input is now array("red", "green",
//          "blue", "black", "maroon")

$input = array("red", "green", "blue", "yellow");
array_splice($input, 3, 0, "purple");
// $input is now array("red", "green",
//          "blue", "purple", "yellow");
?>
```

**Example #2 `array_splice()` 例子**

以下表达式以同样方式修改了 $input：

```php
<?php

// 添加两个新元素到 $input
array_push($input, $x, $y);
array_splice($input, count($input), 0, array($x, $y));

// 移除 $input 中的最后一个元素
array_pop($input);
array_splice($input, -1);

// 移除  $input 中第一个元素
array_shift($input);
array_splice($input, 0, 1);

// 在 $input 的开头插入一个元素
array_unshift($input, $x, $y);
array_splice($input, 0, 0, array($x, $y));

// 在 $input  的索引  $x 处替换值
$input[$x] = $y; // 对于键名和偏移量等值的数组
array_splice($input, $x, 1, $y);
?>
```

------



#### array_sum

对数组中所有值求和

**说明**

```php
array_sum ( array $array ) : number
```

​	**array_sum()** 将数组中的所有值相加，并返回结果。

**参数**

`array`

​	输入的数组

**返回值**

​	所有值的和以整数或浮点数的结果返回，`array`为空时则返回*0*。

------



#### =====array_udiff_assoc

带索引检查计算数组的差集，用回调函数比较数据

**说明**

```php
array_udiff_assoc ( array $array1 , array $array2 [, array $... ], callable $value_compare_func ) : array
```

​	此比较是通过用户提供的回调函数来进行的。如果认为第一个参数小于，等于，或大于第二个参数时必须分别返回一个小于零，等于零，或大于零的整数。

> **Note**: 注意本函数只检查了多维数组中的一维。当然，可以用*array_udiff_assoc($array1[0], $array2[0], "some_comparison_func");* 来检查更深的维度。

**参数**

`array1`

​	第一个数组。

`array2`

​	第二个数组。

`value_compare_func`

​	在第一个参数小于，等于或大于第二个参数时，该比较函数必须相应地返回一个小于，等于或大于 0 的整数。

```php
callback ( mixed $a, mixed $b ) : int
```

**返回值**

​	**array_udiff_assoc()** 返回一个数组，该数组包括了所有在 `array1` 中但是不在任何其它参数数组中的值。注意和 [array_diff()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-diff.html) 与 [array_udiff()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-udiff.html) 不同的是键名也用于比较。数组数据的比较是用用户提供的回调函数进行的。在此方面和[array_diff_assoc()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array-diff-assoc.html) 的行为正好相反，后者是用内部函数进行比较的。

**范例**

------



#### =====array_udiff_uassoc

#### =====array_udiff

#### =====array_uintersect_assoc

#### =====array_uintersect_uassoc

#### =====array_uintersect

#### array_unique

移除数组中重复的值

**说明**

```php
array_unique ( array $array [, int $sort_flags = SORT_STRING ] ) : array
```

​	**array_unique()** 接受 `array` 作为输入并返回没有重复值的新数组。

​	注意键名保留不变。**array_unique()** 先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 `array` 中同一个值的第一个出现的键名会被保留。

> **Note**: 当且仅当 *(string) $elem1 === (string) $elem2* 时两个单元被认为相同。 例如，字符串表达一样时，会使用首个元素。

**参数**

`array`

​	输入的数组。

`sort_flags`

​	第二个可选参数`sort_flags` 可用于修改排序行为：

​	排序类型标记：

- **`SORT_REGULAR`** - 按照通常方法比较（不修改类型）
- **`SORT_NUMERIC`** - 按照数字形式比较
- **`SORT_STRING`** - 按照字符串形式比较
- **`SORT_LOCALE_STRING`** - 根据当前的本地化设置，按照字符串比较。

**返回值**

​	返回过滤后的数组

**范例**

**Example #1 `array_unique()` 例子**

```php
<?php
$input = array("a" => "green", "red", "b" => "green", "blue", "red");
$result = array_unique($input);
print_r($result);
?>
```

以上例程会输出：

```
Array
(
    [a] => green
    [0] => red
    [1] => blue
)
```



**Example #2 `array_unique()` 和类型**

```php
<?php
$input = array(4, "4", "3", 4, 3, "3");
$result = array_unique($input);
var_dump($result);
?>
```

以上例程会输出：

```
array(2) {
  [0] => int(4)
  [2] => string(1) "3"
}
```

------



#### array_unshift

在数组开头插入一个或多个单元

**说明**

```php
array_unshift ( array &$array [, mixed $... ] ) : int
```

​	**array_unshift()** 将传入的单元插入到 `array` 数组的开头。注意单元是作为整体被插入的，因此传入单元将保持同样的顺序。所有的数值键名将修改为从零开始重新计数，所有的文字键名保持不变。

**参数**

`array`

​	输入的数组。

`...`

​	插入的变量。

**返回值**

​	返回 `array` 数组新的单元数目。

------



#### array_values

返回数组中所有的值

**说明**

```php
array_values ( array $array ) : array
```

​	array_values返回 `input` 数组中所有的值并给其建立数字索引。

**参数**

`array`	

​	数组。

**返回值**

​	返回含所有值的索引数组。

------



#### array_walk_recursive

对数组中的每个成员递归地应用用户函数

**说明**

```php
array_walk_recursive ( array &$array , callable $callback [, mixed $userdata = NULL ] ) : bool
```

​	将用户自定义函数 `callback` 应用到 `array` 数组中的每个单元。本函数会递归到更深层的数组中去。

**参数**

`array`

​	输入的数组。

`callback`

​	典型情况下 `callback` 接受两个参数。`array` 参数的值作为第一个，键名作为第二个。

> **Note**: 
>
> 如果 `callback` 需要直接作用于数组中的值，则给 `callback` 的第一个参数指定为[引用](chm://81c5fd530434a6e8d06943912d065c49/res/language.references.html)。这样任何对这些单元的改变也将会改变原始数组本身。

`userdata`

​	如果提供了可选参数 `userdata`，将被作为第三个参数传递给 `callback`。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**

**Example #1 `array_walk_recursive()` 例子**

```php
<?php
$sweet = array('a' => 'apple', 'b' => 'banana');
$fruits = array('sweet' => $sweet, 'sour' => 'lemon');

function test_print($item, $key)
{
    echo "$key holds $item\n";
}

array_walk_recursive($fruits, 'test_print');
?>
```

以上例程会输出：

```
a holds apple
b holds banana
sour holds lemon
```

注意上例中的键 '*sweet*' 并没有显示出来。任何其值为 [array](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.array.html) 的键都不会被传递到回调函数中去。

------



#### array_walk

使用用户自定义函数对数组中的每个元素做回调处理。

**说明**

```php
array_walk ( array &$array , callable $callback [, mixed $userdata = NULL ] ) : bool
```

​	将用户自定义函数 `funcname` 应用到 `array` 数组中的每个单元。

​	如果 array 为二维数组，会发出一个`notice`

​	**array_walk()** 不会受到 `array` 内部数组指针的影响。**array_walk()** 会遍历整个数组而不管指针的位置。

**参数**

`array`

​	输入的数组。

`callback`

​	典型情况下 `callback` 接受两个参数。`array` 参数的值作为第一个，键名作为第二个。

> **Note**: 
>
> 如果 `callback` 需要直接作用于数组中的值，则给 `callback` 的第一个参数指定为[引用](chm://81c5fd530434a6e8d06943912d065c49/res/language.references.html)。这样任何对这些单元的改变也将会改变原始数组本身。

> **Note**: 
>
> 参数数量超过预期，传入内置函数 (例如 [strtolower()](chm://81c5fd530434a6e8d06943912d065c49/res/function.strtolower.html))， 将抛出警告，所以不适合当做 `funcname`。

​	只有 `array` 的值才可以被改变，用户不应在回调函数中改变该数组本身的结构。例如增加/删除单元，unset 单元等等。如果 **array_walk()** 作用的数组改变了，则此函数的的行为未经定义，且不可预期。

`userdata`

​	如果提供了可选参数 `userdata`，将被作为第三个参数传递给 callback `funcname`。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**错误/异常**

​	如果 `callback` 函数需要的参数比给出的多，则每次 **array_walk()** 调用 `callback`时都会产生一个 [E_WARNING](chm://81c5fd530434a6e8d06943912d065c49/res/errorfunc.constants.html) 级的错误。

**范例**

**Example #1 `array_walk()` 例子**

```php
<?php
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");

function test_alter(&$item1, $key, $prefix)
{
    $item1 = "$prefix: $item1";
}

function test_print($item2, $key)
{
    echo "$key. $item2<br />\n";
}

echo "Before ...:\n";
array_walk($fruits, 'test_print');

array_walk($fruits, 'test_alter', 'fruit');
echo "... and after:\n";

array_walk($fruits, 'test_print');
?>
```

以上例程会输出：

```
Before ...:
d. lemon
a. orange
b. banana
c. apple
... and after:
d. fruit: lemon
a. fruit: orange
b. fruit: banana
c. fruit: apple
```

------



#### array

新建一个数组

------



####  arsort

对数组按照值进行逆向排序并保持索引关系

**说明**

```php
arsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool
```

​	本函数对数组进行排序，数组的索引保持和单元的关联。

**参数**

`array`

​	输入的数组。

`sort_flags`

​	可以用可选的参数 `sort_flags` 改变排序的行为，详情见 [sort()](chm://81c5fd530434a6e8d06943912d065c49/res/function.sort.html)。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**

**Example #1 `arsort()` 例子**

```php
<?php
$fruits = array("d" => "lemon", "a" => "orange", "b" => "banana", "c" => "apple");
arsort($fruits);
foreach ($fruits as $key => $val) {
    echo "$key = $val\n";
}
?>
```

以上例程会输出：

```
a = orange
d = lemon
b = banana
c = apple
```

fruits 被按照字母顺序逆向排序，并且单元的索引关系不变。

------



 #### asort

对数组进行排序并保持索引关系

**说明**

```php
asort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool
```

​	本函数对数组进行排序，数组的索引保持和单元的关联。

**参数**

`array`

​	输入的数组。

`sort_flags`

​	可以用可选的参数 `sort_flags` 改变排序的行为，详情见 [sort()](chm://81c5fd530434a6e8d06943912d065c49/res/function.sort.html)。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

------



#### compact

建立一个数组，包括变量名和他们的值

**说明**

```php
compact ( mixed $varname1 [, mixed $... ] ) : array
```

​	对每个参数，**compact()** 在当前的符号表中查找该变量名并将它添加到输出的数组中，变量名成为键名而变量的内容成为该键的值。简单说，它做的事和 [extract()](chm://81c5fd530434a6e8d06943912d065c49/res/function.extract.html) 正好相反。返回将所有变量添加进去后的数组。

> **Note**: 
>
> 在 PHP 7.3 之前版本，未设置的字符串会被静默忽略。

**参数**

`varname1`

​	compact() 接受可变的参数数目。每个参数可以是一个包括变量名的字符串或者是一个包含变量名的数组，该数组中还可以包含其它单元内容为变量名的数组， compact() 可以递归处理。

**返回值**

​	返回输出的数组，包含了添加的所有变量。

**错误/异常**

​	如果字符串指向的变量未定义，**compact()** 会产生 E_NOTICE 级错误。

**范例**

**Example #1 `compact()` 例子**

```php
<?php
$city  = "San Francisco";
$state = "CA";
$event = "SIGGRAPH";

$location_vars = array("city", "state");

$result = compact("event", "nothing_here", $location_vars);
print_r($result);
?>
```

以上例程会输出：

```
Array
(
    [event] => SIGGRAPH
    [city] => San Francisco
    [state] => CA
)
```

**注释**

> **Note**: **Gotcha**
>
> 因为[可变变量](chm://81c5fd530434a6e8d06943912d065c49/res/language.variables.variable.html)也许不能在函数内部用于 PHP 的[超全局数组](chm://81c5fd530434a6e8d06943912d065c49/res/language.variables.superglobals.html)，此时不能将超全局数组传递入 **compact()** 中。

------



#### count / sizeof

计算数组中的单元数目，或对象中的属性个数

**说明**

```php
count ( mixed $array_or_countable [, int $mode = COUNT_NORMAL ] ) : int
```

​	统计出数组里的所有元素的数量，或者对象里的东西。

**参数**

`array_or_countable`

​	数组或者 [Countable](chm://81c5fd530434a6e8d06943912d065c49/res/class.countable.html) 对象。

`mode`

​	如果可选的 `mode` 参数设为 **`COUNT_RECURSIVE`**（或 1），**count()** 将递归地对数组计数。*对计算多维数组的所有单元尤其有用。*

> **Caution**
>
> **count()** 能检测递归来避免无限循环，但每次出现时会产生 **`E_WARNING`** 错误 （如果 array 不止一次包含了自身）并返回大于预期的统计数字。

**返回值**

​	返回 `array_or_countable` 中的单元数目。 如果参数既不是数组，也不是实现*Countable* 接口的对象，将返回 *1*。 有个例外：如果 `array_or_countable` 是 **`NULL`** 则结果是 *0*。

> 在7.2.0版本中，当无效的 countable 类型传递给 `array_or_countable` 参数时，**count()** 会产生警告。

------



#### current / pos

返回数组中的当前单元

**说明**

```php
current ( array &$array ) : mixed
```

​	每个数组中都有一个内部的指针指向它"当前的"单元，初始指向插入到数组中的第一个单元。

**参数**

`array`

​	这个数组。

**返回值**

​	**current()** 函数返回当前被内部指针指向的数组单元的值，并不移动指针。如果内部指针指向超出了单元列表的末端，**current()** 返回 **`FALSE`**。

**范例**

**Example #1 使用 `current()` 系列函数的例子**

```php
<?php
$transport = array('foot', 'bike', 'car', 'plane');
$mode = current($transport); // $mode = 'foot';
$mode = next($transport);    // $mode = 'bike';
$mode = current($transport); // $mode = 'bike';
$mode = prev($transport);    // $mode = 'foot';
$mode = end($transport);     // $mode = 'plane';
$mode = current($transport); // $mode = 'plane';

$arr = array();
var_dump(current($arr)); // bool(false)

$arr = array(array());
var_dump(current($arr)); // array(0) { }
?>
```

**注释**

> **Note**: 如果数组包含 [boolean](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.boolean.html) **`FALSE`** 的单元则本函数在碰到这个单元时也返回**`FALSE`**，使得不可能判断是否到了此数组列表的末端。 要正确遍历可能含有空单元的数组，用 [each()](chm://81c5fd530434a6e8d06943912d065c49/res/function.each.html) 函数。

**参见**

- [end()](chm://81c5fd530434a6e8d06943912d065c49/res/function.end.html) - 将数组的内部指针指向最后一个单元
- [key()](chm://81c5fd530434a6e8d06943912d065c49/res/function.key.html) - 从关联数组中取得键名
- [each()](chm://81c5fd530434a6e8d06943912d065c49/res/function.each.html) - 返回数组中当前的键／值对并将数组指针向前移动一步
- [prev()](chm://81c5fd530434a6e8d06943912d065c49/res/function.prev.html) - 将数组的内部指针倒回一位
- [reset()](chm://81c5fd530434a6e8d06943912d065c49/res/function.reset.html) - 将数组的内部指针指向第一个单元
- [next()](chm://81c5fd530434a6e8d06943912d065c49/res/function.next.html) - 将数组中的内部指针向前移动一位

------



#### each

返回数组中当前的键/值对并将数组指针向前移动一步

**说明**

```php
each ( array &$array ) : array
```

​	返回数组中当前的键／值对并将数组指针向前移动一步

​	在执行 **each()** 之后，数组指针将停留在数组中的下一个单元或者当碰到数组结尾时停留在最后一个单元。如果要再用 each 遍历数组，必须使用 [reset()](chm://81c5fd530434a6e8d06943912d065c49/res/function.reset.html)。

**参数**

`array`

​	输入的数组

**返回值**

​	返回 `array` 数组中当前指针位置的键／值对并向前移动数组指针。键值对被返回为四个单元的数组，键名为*0*，*1*，*key*和 *value*。单元 *0* 和 *key* 包含有数组单元的键名，*1* 和 *value* 包含有数据。

​	如果内部指针越过了数组的末端，则 **each()** 返回 **`FALSE`**。

**范例**

**Example #1 `each()` 例子**

```php
<?php
$foo = array("bob", "fred", "jussi", "jouni", "egon", "marliese");
$bar = each($foo);
print_r($bar);
?>
```

$bar 现在包含有如下的键／值对：

```
Array
(
    [1] => bob
    [value] => bob
    [0] => 0
    [key] => 0
)
```



```php
<?php
$foo = array("Robert" => "Bob", "Seppo" => "Sepi");
$bar = each($foo);
print_r($bar);
?>
```

$bar 现在包含有如下的键／值对：

```
Array
(
    [1] => Bob
    [value] => Bob
    [0] => Robert
    [key] => Robert
)
```

**each()** 经常和 [list()](chm://81c5fd530434a6e8d06943912d065c49/res/function.list.html) 结合使用来遍历数组，例如：

**Example #2 用 `each()` 遍历数组**

```php
<?php
$fruit = array('a' => 'apple', 'b' => 'banana', 'c' => 'cranberry');

reset($fruit);
while (list($key, $val) = each($fruit)) {
    echo "$key => $val\n";
}
?>
```

以上例程会输出：

```
a => apple
b => banana
c => cranberry
```

> **Caution**
>
> 因为将一个数组赋值给另一个数组时会重置原来的数组指针，因此在上边的例子中如果我们在循环内部将 $fruit 赋给了另一个变量的话将会导致无限循环。

------



#### end

将数组的内部指针指向最后一个单元

**说明**

```php
end ( array &$array ) : mixed
```

​	**end()** 将 `array` 的内部指针移动到最后一个单元并返回其值。

**参数**

`array`

​	这个数组。 该数组是通过引用传递的，因为它会被这个函数修改。 这意味着你必须传入一个真正的变量，而不是函数返回的数组，因为只有真正的变量才能以引用传递。

**返回值**

​	返回最后一个元素的值，或者如果是空数组则返回 **`FALSE`**。

------



#### =====extract

从数组中将变量导入到当前的符号表

**说明**

```php
extract ( array &$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL ]] ) : int
```

​	本函数用来将变量从数组中导入到当前的符号表中。

​	检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有的变量名的冲突。

**参数**

**返回值**

------



#### in_array

检查数组中是否存在某个值

**说明**

```php
in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : bool
```

​	大海捞针，在大海（`haystack`）中搜索针（ `needle`），如果没有设置 `strict`则使用宽松的比较。

**参数**

`needle`

​	待搜索的值。

> **Note**: 
>
> 如果 `needle` 是字符串，则比较是区分大小写的。

`haystack`

​	待搜索的数组。

`strict`

​	如果第三个参数 `strict` 的值为 **`TRUE`** 则 **in_array()** 函数还会检查 `needle`的[类型](chm://81c5fd530434a6e8d06943912d065c49/res/language.types.html)是否和 `haystack` 中的相同。

**返回值**

​	如果找到 `needle` 则返回 **`TRUE`**，否则返回 **`FALSE`**。

------



#### key

从关联数组中取得键名

**说明**

```php
key ( array $array ) : mixed
```

​	**key()** 返回数组中当前单元的键名。

**参数**

`array`

​	该数组

**返回值**

​	**key()** 函数返回数组中内部指针指向的当前单元的键名。 但它不会移动指针。如果内部指针超过了元素列表尾部，或者数组是空的，**key()** 会返回 **`NULL`**。

------



#### krsort

对数组按照键名逆向排序

**说明**

```php
krsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool
```

​	对数组按照键名逆向排序，保留键名到数据的关联。主要用于结合数组。

**参数**

`array`

​	输入的数组。

`sort_flags`

​	可以用可选参数 `sort_flags` 改变排序的行为，详情见 [sort()](chm://81c5fd530434a6e8d06943912d065c49/res/function.sort.html)。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

------



#### ksort

对数组按照键名排序。其余请参照 `krsort`

------



#### list

把数组中的值赋给一组变量

**说明**

```php
list ( mixed $var1 [, mixed $... ] ) : array
```

​	像 [array()](chm://81c5fd530434a6e8d06943912d065c49/res/function.array.html) 一样，这不是真正的函数，而是语言结构。 **list()** 可以在单次操作内就为一组变量赋值。

> **Warning**
>
> 在 **list()** 执行过程中修改数组（比如使用 *list($a, $b) = $b*）将会产生不可预知的结果。

**参数**

`var1`

​	一个变量

**返回值**

​	返回指定的数组

**范例**

**Example #1 `list()` 例子**

```php
<?php

$info = array('coffee', 'brown', 'caffeine');

// 列出所有变量
list($drink, $color, $power) = $info;
echo "$drink is $color and $power makes it special.\n";

// 列出他们的其中一个
list($drink, , $power) = $info;
echo "$drink has $power.\n";

// 或者让我们跳到仅第三个
list( , , $power) = $info;
echo "I need $power!\n";

// list() 不能对字符串起作用
list($bar) = "abcde";
var_dump($bar); // NULL
?>
```

**Example #3 使用嵌套的 `list()`**

```php
<?php

list($a, list($b, $c)) = array(1, array(2, 3));

var_dump($a, $b, $c);

?>
```

```
int(1)
int(2)
int(3)
```

**Example #4 在 `list()` 中使用数组索引**

```php
<?php

$info = array('coffee', 'brown', 'caffeine');

list($a[0], $a[1], $a[2]) = $info;

var_dump($a);

?>
```

产生如下输出（注意单元顺序和 **list()** 语法中所写的顺序的比较）：

Output of the above example in PHP 7:

```
array(3) {
  [0]=>
  string(6) "coffee"
  [1]=>
  string(5) "brown"
  [2]=>
  string(8) "caffeine"
}
```

Output of the above example in PHP 5:

```
array(3) {
  [2]=>
  string(8) "caffeine"
  [1]=>
  string(5) "brown"
  [0]=>
  string(6) "coffee"
}
```



**Example #5 `list()` 和索引顺序定义**

**list()** 使用 array 索引的顺序和它何时定义无关。

```php
<?php
$foo = array(2 => 'a', 'foo' => 'b', 0 => 'c');
$foo[1] = 'd';
list($x, $y, $z) = $foo;
var_dump($foo, $x, $y, $z);
```

得到以下输出（注意比较 **list()** 所写的元素顺序）：

```
array(4) {
  [2]=>
  string(1) "a"
  ["foo"]=>
  string(1) "b"
  [0]=>
  string(1) "c"
  [1]=>
  string(1) "d"
}
string(1) "c"
string(1) "d"
string(1) "a"
```



**Example #6 带键的 `list()`**

从 PHP 7.1.0 开始，**list()** 可以包含显式的键，可赋值到任意表达式。 可以混合使用数字和字符串键。但是不能混合有键和无键不能混用。

```php
<?php
$data = [
    ["id" => 1, "name" => 'Tom'],
    ["id" => 2, "name" => 'Fred'],
];
foreach ($data as ["id" => $id, "name" => $name]) {
    echo "id: $id, name: $name\n";
}
echo PHP_EOL;
list(1 => $second, 3 => $fourth) = [1, 2, 3, 4];
echo "$second, $fourth\n";
```

以上例程会输出：

```
id: 1, name: Tom
id: 2, name: Fred

2, 4
```

------



#### natcasesort

用“自然排序”算法对数组进行不区分大小写字母的排序

**说明**

```php
natcasesort ( array &$array ) : bool
```

​	**natcasesort()** 是 [natsort()](https://www.php.net/manual/zh/function.natsort.php) 函数的不区分大小写字母的版本。

​	本函数实现了一个和人们通常对字母数字字符串进行排序的方法一样的排序算法并保持原有键／值的关联，这被称为"自然排序"。

**参数**

`array`

​	输入的数组

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**

**Example #1 `natcasesort()` 例子**

```php
<?php
$array1 = $array2 = array('IMG0.png', 'img12.png', 'img10.png', 'img2.png', 'img1.png', 'IMG3.png');

sort($array1);
echo "Standard sorting\n";
print_r($array1);

natcasesort($array2);
echo "\nNatural order sorting (case-insensitive)\n";
print_r($array2);
?>
```

以上例程会输出：

```
Standard sorting
Array
(
    [0] => IMG0.png
    [1] => IMG3.png
    [2] => img1.png
    [3] => img10.png
    [4] => img12.png
    [5] => img2.png
)

Natural order sorting (case-insensitive)
Array
(
    [0] => IMG0.png
    [4] => img1.png
    [3] => img2.png
    [5] => IMG3.png
    [2] => img10.png
    [1] => img12.png
)
```

------



#### natsort

用“自然排序”算法对数组排序。区分大小写

其余参考`natcasesort`

------



#### next

将数组中的内部指针向前移动一位

**说明**

```php
next ( array &$array ) : mixed
```

​	**next()** 和 [current()](https://www.php.net/manual/zh/function.current.php) 的行为类似，只有一点区别，在返回值之前将内部指针向前移动一位。这意味着它返回的是下一个数组单元的值并将数组指针向前移动了一位。

**返回值**

​	返回数组内部指针指向的下一个单元的值，或当没有更多单元时返回 **`FALSE`**。

------



#### prev

将数组的内部指针倒回一位

**说明**

```php
prev ( array &$array ) : mixed
```

​	将数组的内部指针倒回一位。

​	**prev()** 和 [next()](https://www.php.net/manual/zh/function.next.php) 的行为类似，只除了它将内部指针倒回一位而不是前移一位。

**返回值**

​	返回数组内部指针指向的前一个单元的值，或当没有更多单元时返回 **`FALSE`**。

------



#### range

根据范围常见数组，包含指定的元素

**说明**

```php
range ( mixed $start , mixed $end [, number $step = 1 ] ) : array
```

​	建立一个包含指定范围单元的数组。

**参数**

`start`

​	序列的第一个值。

`end`

​	序列结束于 `end` 的值。

`step`

​	如果设置了步长 `step`，会被作为单元之间的步进值。`step` 应该为正值。不设置`step` 则默认为 1。

**返回值**

​	返回的数组中从 `start` 到 `end` （含 start 和 end）的单元。

**注释**

> **Note**:
>
> 字符序列值仅限单个字符。 如果长度大于1，仅仅使用第一个字符。

```php
<?php
print_r(range('ab', 'ci'));   // Array ( [0] => a [1] => b [2] => c )
```

------



#### reset

将数组的内部指针指向第一个单元

**说明**

```php
reset ( array &$array ) : mixed
```

​	**reset()** 将 `array` 的内部指针倒回到第一个单元并返回第一个数组单元的值。

**返回值**

​	返回数组第一个单元的值，如果数组为空则返回 **`FALSE`**。

------



#### rsort

对数组逆向排序

**说明**

```php
rsort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool	
```

​	本函数对数组进行逆向排序（最高到最低）。

**参数**

`array`

​	输入的数组。

`sort_flags`

​	可以用可选参数 `sort_flags` 改变排序的行为，详情见 [sort()](https://www.php.net/manual/zh/function.sort.php)。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**注释**

> **Note**: 此函数为 `array` 中的元素赋与新的键名。这将删除原有的键名，而不是仅仅将键名重新排序。

------



#### shuffle

打乱数组

**说明**

```php
shuffle ( array &$array ) : bool
```

​	本函数打乱（随机排列单元的顺序）一个数组。 它使用的是伪随机数产生器，并不适合密码学的场合。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**注释**

> **Note**: 此函数为 `array` 中的元素赋与新的键名。这将删除原有的键名，而不是仅仅将键名重新排序。

------



#### sort

对数组排序

**说明**

```php
sort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool
```

​	本函数对数组进行排序。当本函数结束时数组单元将被从最低到最高重新安排。

**参数**

`array`

​	要排序的数组。

`sort_flags`

​	可选的第二个参数 `sort_flags` 可以用以下值改变排序的行为：

​	排序类型标记：

- **`SORT_REGULAR`** - 正常比较单元（不改变类型）
- **`SORT_NUMERIC`** - 单元被作为数字来比较
- **`SORT_STRING`** - 单元被作为字符串来比较
- **`SORT_LOCALE_STRING`** - 根据当前的区域（locale）设置来把单元当作字符串比较，可以用 [setlocale()](https://www.php.net/manual/zh/function.setlocale.php) 来改变。
- **`SORT_NATURAL`** - 和 [natsort()](https://www.php.net/manual/zh/function.natsort.php) 类似对每个单元以“自然的顺序”对字符串进行排序。 PHP 5.4.0 中新增的。
- **`SORT_FLAG_CASE`** - 能够与 **`SORT_STRING`** 或 **`SORT_NATURAL`** 合并（OR 位运算），不区分大小写排序字符串。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

------



#### =====uasort

使用用户自定义的比较函数对数组中的值进行排序并保持索引关联

**说明**

```php
uasort ( array &$array , callable $value_compare_func ) : bool
```

​	本函数对数组排序并保持索引和单元之间的关联。

​	主要用于对那些单元顺序很重要的结合数组进行排序。比较函数是用户自定义的。

**参数**

`array`

​	输入的数组。

`value_compare_func`

​	用户自定义比较函数的例子请参考 [usort()](https://www.php.net/manual/zh/function.usort.php) 和 [uksort()](https://www.php.net/manual/zh/function.uksort.php)。

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**

**Example #1 `uasort()` 的基本例子**

```php
<?php
// Comparison function
function cmp($a, $b) {
    if ($a == $b) {
        return 0;
    }
    return ($a < $b) ? -1 : 1;
}

// Array to be sorted
$array = array('a' => 4, 'b' => 8, 'c' => -1, 'd' => -9, 'e' => 2, 'f' => 5, 'g' => 3, 'h' => -4);
print_r($array);

// Sort and print the resulting array
uasort($array, 'cmp');
print_r($array);
?>
```

以上例程会输出：

```
Array
(
    [a] => 4
    [b] => 8
    [c] => -1
    [d] => -9
    [e] => 2
    [f] => 5
    [g] => 3
    [h] => -4
)
Array
(
    [d] => -9
    [h] => -4
    [c] => -1
    [e] => 2
    [g] => 3
    [a] => 4
    [f] => 5
    [b] => 8
)
```

------



#### =====uksort

使用用户自定义的比较函数对数组中的键名进行排序

------



#### usort

使用用户自定义的比较函数对数组中的值进行排序

**说明**

```php
usort ( array &$array , callable $value_compare_func ) : bool
```

​	本函数将用用户自定义的比较函数对一个数组中的值进行排序。 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。

> **Note**: 此函数为 `array` 中的元素赋与新的键名。这将删除原有的键名，而不是仅仅将键名重新排序。

**参数**

`array`

​	输入的数组

`cmp_function`

​	在第一个参数小于，等于或大于第二个参数时，该比较函数必须相应地返回一个小于，等于或大于 0 的整数。

```php
callback ( mixed $a, mixed $b ) : int
```

**返回值**

​	成功时返回 **`TRUE`**， 或者在失败时返回 **`FALSE`**。

**范例**



