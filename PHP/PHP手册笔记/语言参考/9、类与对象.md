## 基本概念

### class

每个类的定义都以关键字 *class* 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。

类名可以是任何非PHP [保留字](https://www.php.net/manual/zh/reserved.php)的合法标签。一个合法类名以字母或下划线开头，后面跟着若干字母，数字或下划线。以正则表达式表示为：*[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]**。

一个类可以包含有属于自己的[常量](https://www.php.net/manual/zh/language.oop5.constants.php)，[变量](https://www.php.net/manual/zh/language.oop5.properties.php)（称为“属性”）以及函数（称为“方法”）。

**Example #1 简单的类定义**

```php
<?php
class SimpleClass
{
	//声明属性
  public $var = 'a deafult value';
  
  //声明方法
  public function displayVar()
  {
    echo $this->var;
  }
}
```

当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象[静态](https://www.php.net/manual/zh/language.oop5.static.php)调用时也可能是另一个对象）。

### new

要创建一个类的实例，必须使用 *new* 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了[构造函数](https://www.php.net/manual/zh/language.oop5.decon.php)并且在出错时抛出了一个[异常](https://www.php.net/manual/zh/language.exceptions.php)。类应在被实例化之前定义（某些情况下则必须这样）。

如果在 *new* 之后跟着的是一个包含有类名的字符串 [string](https://www.php.net/manual/zh/language.types.string.php)，则该类的一个实例被创建。如果该类属于一个命名空间，则必须使用其完整名称。

**Example #3 创建实例**

```php
<?php
$instance = new SimpleClass();

// 也可以这样做：
$className = 'Foo';
$instance = new $className(); // Foo()
?>
```

在类定义内部，可以用 *new self* 和 *new parent* 创建新对象。

当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用[克隆](https://www.php.net/manual/zh/language.oop5.cloning.php)给一个已创建的对象建立一个新实例。

**Example #4 对象赋值**

```php
<?php

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned will have this value';

$instance = null; // $instance and $reference become null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
```

以上例程会输出：

```
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned will have this value"
}
```

PHP 5.3.0 引进了两个新方法来创建一个对象的实例：

**Example #5 创建新对象**

```php
<?php
class Test
{
    static public function getNew()
    {
        return new static;// static 代表当前类
    }
}

class Child extends Test
{}

$obj1 = new Test();
$obj2 = new $obj1;
var_dump($obj1 !== $obj2);

$obj3 = Test::getNew();
var_dump($obj3 instanceof Test);

$obj4 = Child::getNew();
var_dump($obj4 instanceof Child);
?>
```

以上例程会输出：

```
bool(true)
bool(true)
bool(true)
```

PHP 5.4.0 起，可以通过一个表达式来访问新创建对象的成员：

**Example #6 访问新创建对象的成员**

```php
<?php
echo (new DateTime())->format('Y');
?>
```

以上例程的输出类似于：

```
2020
```



## 属性

类的变量成员叫做“属性”，或者叫“字段”、“特征”，在本文档统一称为“属性”。属性声明是由关键字 *public*，*protected* 或者 *private* 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。

有关 *public*，*protected* 和 *private* 的更多详细信息，请查看[访问控制（可见性）](https://www.php.net/manual/zh/language.oop5.visibility.php)。

在类的成员方法里面，可以用 *->*（对象运算符）：$this->property（其中 *property* 是该属性名）这种方式来访问非静态属性。静态属性则是用 *::*（双冒号）：self::$property 来访问。更多静态属性与非静态属性的区别参见 [Static 关键字](https://www.php.net/manual/zh/language.oop5.static.php)。

当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象[静态](https://www.php.net/manual/zh/language.oop5.static.php)调用时也可能是另一个对象）。

**Example #1 属性声明**

```php
<?php
class SimpleClass
{
   // 错误的属性声明
   public $var1 = 'hello ' . 'world';
   public $var2 = <<<EOD
hello world
EOD;
   public $var3 = 1+2;
   public $var4 = self::myStaticMethod();
   public $var5 = $myVar;

   // 正确的属性声明
   public $var6 = myConstant;
   public $var7 = array(true, false);

   //在 PHP 5.3.0 及之后，下面的声明也正确
   public $var8 = <<<'EOD'
hello world
EOD;
}
?>
```

> **Note**:
>
> 更多关于类／对象的处理函数，请查看[类／对象函数](https://www.php.net/manual/zh/ref.classobj.php)。

跟 [heredocs](https://www.php.net/manual/zh/language.types.string.php#language.types.string.syntax.heredoc) 不同，[nowdocs](https://www.php.net/manual/zh/language.types.string.php#language.types.string.syntax.nowdoc) 可在任何静态数据上下文中使用，包括属性声明。

**Example #2 示例：使用 nowdoc 初始化属性**

```php
<?php
class foo {
   // 自 5.3.0 起
   public $bar = <<<'EOT'
bar
EOT;
}
?>
```

> **Note**:
>
> Nowdoc 支持是在 PHP 5.3.0 新增的。



## 类常量

可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。

常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。

接口（interface）中也可以定义常量。更多示例见文档中的[接口](https://www.php.net/manual/zh/language.oop5.interfaces.php)部分。

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 *self*，*parent* 或 *static*）。

**Example #1 定义和使用一个类常量**

```php
<?php
class MyClass
{
    const constant = 'constant value';

    function showConstant() {
        echo  self::constant . "\n";
    }
}

echo MyClass::constant . "\n";

$classname = "MyClass";
echo $classname::constant . "\n"; // 自 5.3.0 起

$class = new MyClass();
$class->showConstant();

echo $class::constant."\n"; // 自 PHP 5.3.0 起
?>
```



## 类的自动加载

在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。

在 PHP 5 中，已经不再需要这样了。 [spl_autoload_register()](https://www.php.net/manual/zh/function.spl-autoload-register.php) 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。

> #### Tip
>
> 尽管 [__autoload()](https://www.php.net/manual/zh/function.autoload.php) 函数也能自动加载类和接口，但更建议使用 [spl_autoload_register()](https://www.php.net/manual/zh/function.spl-autoload-register.php) 函数。 [spl_autoload_register()](https://www.php.net/manual/zh/function.spl-autoload-register.php) 提供了一种更加灵活的方式来实现类的自动加载（同一个应用中，可以支持任意数量的加载器，比如第三方库中的）。因此，不再建议使用 [__autoload()](https://www.php.net/manual/zh/function.autoload.php) 函数，在以后的版本中它可能被弃用。

> **Note**:
>
> 在 PHP 5.3 之前，__autoload 函数抛出的异常不能被 [catch](https://www.php.net/manual/zh/language.exceptions.php) 语句块捕获并会导致一个致命错误（Fatal Error）。 自 PHP 5.3 起，能够 thrown 自定义的异常（Exception），随后自定义异常类即可使用。 __autoload 函数可以递归的自动加载自定义异常类。

**Example #1 自动加载示例**

本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 *MyClass1* 和 *MyClass2* 类。

```php
<?php
spl_autoload_register(function ($class_name) {
    require_once $class_name . '.php';
});

$obj  = new MyClass1();
$obj2 = new MyClass2();
?>
```

**Example #2 另一个例子**

本例尝试加载接口 *ITest*。

```php
<?php

spl_autoload_register(function ($name) {
    var_dump($name);
});

class Foo implements ITest {
}

/*
string(5) "ITest"

Fatal error: Interface 'ITest' not found in ...
*/
?>
```

**Example #3 自动加载在 PHP 5.3.0+ 中的异常处理**

本例抛出一个异常并在 try/catch 语句块中演示。

```php
<?php
spl_autoload_register(function ($name) {
    echo "Want to load $name.\n";
    throw new Exception("Unable to load $name.");
});

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
```

以上例程会输出：

```
Want to load NonLoadableClass.
Unable to load NonLoadableClass.
```

**Example #4 自动加载在 PHP 5.3.0+ 中的异常处理 - 没有自定义异常机制**

本例将一个异常抛给不存在的自定义异常处理函数。

```php
<?php
spl_autoload_register(function ($name) {
    echo "Want to load $name.\n";
    throw new MissingException("Unable to load $name.");
});

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
```

以上例程会输出：

```
Want to load NonLoadableClass.
Want to load MissingException.

Fatal error: Class 'MissingException' not found in testMissingException.php on line 4
```

### 参见

- [unserialize()](https://www.php.net/manual/zh/function.unserialize.php)
- [unserialize_callback_func](https://www.php.net/manual/zh/var.configuration.php#unserialize-callback-func)
- [spl_autoload_register()](https://www.php.net/manual/zh/function.spl-autoload-register.php)
- [spl_autoload()](https://www.php.net/manual/zh/function.spl-autoload.php)
- [__autoload()](https://www.php.net/manual/zh/function.autoload.php)



## 构造函数和析构函数

### 构造函数

```php
__construct ([ mixed $args [, $... ]] ) : void
```

PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。

> **Note**: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 **parent::__construct()**。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。

**Example #1 使用新标准的构造函数**

```php
<?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

class OtherSubClass extends BaseClass {
    // inherits BaseClass's constructor
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();

?>
```

为了实现向后兼容性，如果 PHP 5 在类中找不到 [__construct()](https://www.php.net/manual/zh/language.oop5.decon.php#object.construct) 函数并且也没有从父类继承一个的话，它就会尝试寻找旧式的构造函数，也就是和类同名的函数。因此唯一会产生兼容性问题的情况是：类中已有一个名为 **__construct()** 的方法却被用于其它用途时。

与其它方法不同，当 [__construct()](https://www.php.net/manual/zh/language.oop5.decon.php#object.construct) 被与父类 [__construct()](https://www.php.net/manual/zh/language.oop5.decon.php#object.construct) 具有不同参数的方法覆盖时，PHP 不会产生一个 **`E_STRICT`** 错误信息。

自 PHP 5.3.3 起，在命名空间中，与类名同名的方法不再作为构造函数。这一改变不影响不在命名空间中的类。

### 析构函数

```php
__destruct ( void ) : void
```

PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。

**Example #3 析构函数示例**

```php
<?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
```

和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 **parent::__destruct()**。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。

析构函数即使在使用 [exit()](https://www.php.net/manual/zh/function.exit.php) 终止脚本运行时也会被调用。在析构函数中调用 [exit()](https://www.php.net/manual/zh/function.exit.php) 将会中止其余关闭操作的运行。

> **Note**:
>
> 析构函数在脚本关闭时调用，此时所有的 HTTP 头信息已经发出。脚本关闭时的工作目录有可能和在 SAPI（如 apache）中时不同。

> **Note**:
>
> 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。



## 访问控制（可见性）

对属性或方法的访问控制，是通过在前面添加关键字 *public*（公有），*protected*（受保护）或 *private*（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。

### 属性的访问控制

类属性必须定义为公有、受保护、私有之一。如果用 *var* 定义，则被视为公有。

### 方法的访问控制

类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。

### 其他对象的访问控制

同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。



## 对象继承

继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。

比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。

继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。

> **Note**:
>
> 除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。

**Example #1 继承示例**

```php
<?php

class foo
{
    public function printItem($string) 
    {
        echo 'Foo: ' . $string . PHP_EOL;
    }
    
    public function printPHP()
    {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class bar extends foo
{
    public function printItem($string)
    {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new foo();
$bar = new bar();
$foo->printItem('baz'); // Output: 'Foo: baz'
$foo->printPHP();       // Output: 'PHP is great' 
$bar->printItem('baz'); // Output: 'Bar: baz'
$bar->printPHP();       // Output: 'PHP is great'

?>
```



## 范围解析操作符（::）

范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问[静态](https://www.php.net/manual/zh/language.oop5.static.php)成员，[类常量](https://www.php.net/manual/zh/language.oop5.constants.php)，还可以用于覆盖类中的属性和方法。

当在类定义之外引用到这些项目时，要使用类名。

自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 *self*，*parent* 和 *static*）。

**Example #1 在类的外部使用 :: 操作符**

```php
<?php
class MyClass {
    const CONST_VALUE = 'A constant value';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE; // 自 PHP 5.3.0 起

echo MyClass::CONST_VALUE;
?>
```

`self`，`parent` 和 `static` 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。

**Example #2 在类定义内部使用 ::**

```php
<?php
class OtherClass extends MyClass
{
    public static $my_static = 'static var';

    public static function doubleColon() {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

$classname = 'OtherClass';
echo $classname::doubleColon(); // 自 PHP 5.3.0 起

OtherClass::doubleColon();
?>
```

当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于[构造函数和析构函数](https://www.php.net/manual/zh/language.oop5.decon.php)，[重载](https://www.php.net/manual/zh/language.oop5.overloading.php)以及[魔术方法](https://www.php.net/manual/zh/language.oop5.magic.php)。

**Example #3 调用父类的方法**

```php
<?php
class MyClass
{
    protected function myFunc() {
        echo "MyClass::myFunc()\n";
    }
}

class OtherClass extends MyClass
{
    // 覆盖了父类的定义
    public function myFunc()
    {
        // 但还是可以调用父类中被覆盖的方法
        parent::myFunc();
        echo "OtherClass::myFunc()\n";
    }
}

$class = new OtherClass();
$class->myFunc();
?>
```

参见 [伪变量的示例](https://www.php.net/manual/zh/language.oop5.basic.php#language.oop5.basic.class.this)。



## Static（静态）关键字

本页说明了用 *static* 关键字来定义静态方法和属性。*static* 也可用于[定义静态变量](https://www.php.net/manual/zh/language.variables.scope.php#language.variables.scope.static)以及[后期静态绑定](https://www.php.net/manual/zh/language.oop5.late-static-bindings.php)。参见上述页面了解 *static* 在其中的用法。

声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。

为了兼容 PHP 4，如果没有指定[访问控制](https://www.php.net/manual/zh/language.oop5.visibility.php)，属性和方法默认为公有。

由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。

静态属性不可以由对象通过 -> 操作符来访问。

用静态方式调用一个非静态方法会导致一个 **`E_STRICT`** 级别的错误。

就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。

自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 *self*，*parent* 或 *static*



## 抽象类

> abstract

PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。

继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的[访问控制](https://www.php.net/manual/zh/language.oop5.visibility.php)必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。

**Example #1 抽象类示例**

```php
<?php
abstract class AbstractClass
{
 // 强制要求子类定义这些方法
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // 普通方法（非抽象方法）
    public function printOut() {
        print $this->getValue() . "\n";
    }
}

class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

class ConcreteClass2 extends AbstractClass
{
    public function getValue() {
        return "ConcreteClass2";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass2";
    }
}

$class1 = new ConcreteClass1;
$class1->printOut();
echo $class1->prefixValue('FOO_') ."\n";

$class2 = new ConcreteClass2;
$class2->printOut();
echo $class2->prefixValue('FOO_') ."\n";
?>
```

以上例程会输出：

```
ConcreteClass1
FOO_ConcreteClass1
ConcreteClass2
FOO_ConcreteClass2
```

**Example #2 抽象类示例**

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```

以上例程会输出：

```
Mr. Pacman
Mrs. Pacwoman
```

老代码中如果没有自定义类或函数被命名为“abstract”，则应该能不加修改地正常运行。



## 对象接口

[接口与抽象类异同点](https://juejin.im/entry/590c380061ff4b0062397af8)

使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。

接口是通过 *interface* 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。

接口中定义的所有方法都必须是公有，这是接口的特性。

需要注意的是，在接口中定义一个[构造方法](https://www.php.net/manual/zh/language.oop5.decon.php#language.oop5.decon.constructor)是被允许的。在有些场景下这可能会很有用，例如用于工厂模式时。

### 实现（implements）

要实现一个接口，使用 *implements* 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。

> **Note**:
>
> 在 PHP 5.3.9 之前，实现多个接口时，接口中的方法不能有重名，因为这可能会有歧义。在最近的 PHP 版本中，只要这些重名的方法签名相同，这种行为就是允许的。

> **Note**:
>
> 接口也可以继承，通过使用 [extends](https://www.php.net/manual/zh/language.oop5.inheritance.php) 操作符。

> **Note**:
>
> 类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。

### 常量

接口中也可以定义常量。接口常量和类常量完全相同，但是不能被子类或自接口所覆盖。

### 范例

**Example #1 接口示例**

```php
<?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
// 下面的写法是正确的
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// 下面的写法是错误的，会报错，因为没有实现 getHtml()：
// Fatal error: Class BadTemplate contains 1 abstract methods
// and must therefore be declared abstract (iTemplate::getHtml)
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
}
?>
```

**Example #2 可扩充的接口**

```php
<?php
interface a
{
    public function foo();
}

interface b extends a
{
    public function baz(Baz $baz);
}

// 正确写法
class c implements b
{
    public function foo()
    {
    }

    public function baz(Baz $baz)
    {
    }
}

// 错误写法会导致一个致命错误
class d implements b
{
    public function foo()
    {
    }

    public function baz(Foo $foo)
    {
    }
}
?>
```

**Example #3 继承多个接口**

```php
<?php
interface a
{
    public function foo();
}

interface b
{
    public function bar();
}

interface c extends a, b
{
    public function baz();
}

class d implements c
{
    public function foo()
    {
    }

    public function bar()
    {
    }

    public function baz()
    {
    }
}
?>
```

**Example #4 使用接口常量**

```php
<?php
interface a
{
    const b = 'Interface constant';
}

// 输出接口常量
echo a::b;

// 错误写法，因为常量不能被覆盖。接口常量的概念和类常量是一样的。
class b implements a
{
    const b = 'Class constant';
}
?>
```

接口加上类型约束，提供了一种很好的方式来确保某个对象包含有某些方法。参见 [instanceof](https://www.php.net/manual/zh/language.operators.type.php) 操作符和[类型约束](https://www.php.net/manual/zh/language.oop5.typehinting.php)。

